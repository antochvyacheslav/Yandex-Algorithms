//https://contest.yandex.ru/contest/25070/run-report/110295472/

/*
-- ПРИНЦИП РАБОТЫ --

Для условия этой задачи можно развернуть один из тип дорог в обратную сторону, тогда задачу свдётся к задаче поиска цикла в графе.
Нужно будет проверить от любой вершины в графе нет циклов.
Для поиска цикла используется алгоритм обхода в глубину DFS (Тема 1/2: Графы → Урок 4/13, Тема 1/2: Графы → Урок 5/13)
https://github.com/Yandex-Practicum/algorithms-theory-examples/blob/master/sprint6/By%20languages/C%2B%2B/lesson4code2.cpp

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

От одного города до другого можно проехать только по маршруту, состоящему исключительно из дорог типа R или только из дорог типа B.
По дорогам можно двигаться только от города с меньшим номером к городу с большим номером.
Второе условие как раз позволяет развернуть один из типов дорог.
Если один из типов дорог развёрнут в обратную сторону, то тогда если первое условие будет нарушено, то в графе будет цикл.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Граф представлен в виде списка смежности.
Перебираются все смежные вершины, т.е. все рёбра, исходящие из вершины.
Поскольку алгоритм обрабатывает все вершины, ему придётся пройтись по всем спискам смежности.
Это эквивалентно тому, чтобы пройти по каждому ребру по одному разу, что займёт O(E).
Получим, что итоговая сложность алгоритма O(V+E).
DFS вызывается от каждой вершины, т.е. O(V^2 + E)
Цвета для рёбер при каждом следующем запуске не сбрасываются, 
т.е. помеченные рёбра заново не обрабатываются, а значит все рёбра будут пройдены лишь один раз.
E - количество рёбер, по условию задачи рёбра исходят от каждой младшей вершины ко всем вершинам старше,
т.е. для 4 вершин это будет 3+2+1=6 ребёр, это ряд из натуральных чисел, n-я сумма ряда S=n*(n+1)/2,
в данном случае число рёбер для V вершин вычисляется по формуле E=(V-1)*V/2 (V-1 потому что для V=4 вершин начинаем считать с 3)
т.е. O(E)=O(V^2), тогда O(V^2 + E) = O(V^2 + V^2) = O(V^2)
Итоговая временная сложность: O(V^2)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Т.к. DFS осуществляется через рекурсию, то на каждом уровне рекурсии на стеке будет создаваться стековый кадр,
где выделяется память переданные вызывающей функией аргументы и под локальные перменные метода.
Число вызовов равно числу инцидентных вершин, в худшем случае равно O(V).
Вектор цветов - O(V) памяти.
Сам граф в виде списка смежности будет хранить E=(V-1)*V/2 рёбер, т.е. O(V^2) памяти.
Итоговая пространственная сложность: O(V+V+V^2)=O(V^2)
*/

#include <iostream>
#include <vector>

using namespace std;

enum Color { White, Gray, Black };

vector<Color> color; // Вектор цветов вершин.
bool isCycle;

void DFS(int v, vector<vector<int>>& adjList) { // v - номер вершины
	color[v] = Gray; // Вершина посещена, но ещё не обработана.
	for (int w : adjList[v]) { // Перебираем смежные вершины.
		if (color[w] == White) { // Если вершина не посещена, то
			DFS(w, adjList); // запустим обход от найденной смежной вершины.
		}
		// Если при проверке смежных по исходящим дугам вершин очередная вершина окажется серой — цикл есть
		else if (color[w] == Gray) {
			isCycle = true;
		}
	}
	color[v] = Black; // Теперь вершина обработана.
}

int main() {
	int n;
	cin >> n;
	vector<vector<int>> graph(n + 1);
	for (int i = 1; i < n; ++i) {
		string str;
		cin >> str;
		int j = i + 1;
		for (const auto& ch : str) {
			switch (ch) {
			case 'B': graph[i].push_back(j); break;
			case 'R': graph[j].push_back(i); break;
			}
			++j;
		}
	}
	// Инициализируем вектор цветов
	color.assign(n + 1, White);
	isCycle = false;
	for (int i = 1; i <= n && !isCycle; ++i) {
		// Запускаем обход в глубину от каждой вершины
		DFS(i, graph);
	}
	// cout при использовании тернарного оператора вместо NO и YES почему-то выводит 0 и 1,
	// видимо происходит преобразование типа для "NO" и "YES" к bool
	cout << static_cast<string>(isCycle ? "NO" : "YES");
}
