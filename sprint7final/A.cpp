//https://contest.yandex.ru/contest/25597/run-report/111386174/

/*
-- ПРИНЦИП РАБОТЫ --

https://www.geeksforgeeks.org/introduction-to-levenshtein-distance/
https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0

Алгоритм Вагнера — Фишера

dp(0, 0) = 0
для всех j от 1 до N
  dp(0, j) = dp(0, j - 1) + цена вставки символа S2[j]
для всех i от 1 до M
  dp(i, 0) = dp(i - 1, 0) + цена удаления символа S1[i]
для всех j от 1 до N
  dp(i, j) = min{
    dp(i - 1, j) + цена удаления символа S1[i],
    dp(i, j - 1) + цена вставки символа S2[j],
    dp(i - 1, j - 1) + цена замены символа S1[i] на символ S2[j]
   }
вернуть dp(M, N)

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0#%D0%A4%D0%BE%D1%80%D0%BC%D1%83%D0%BB%D0%B0

Редакционное расстояние между двумя пустыми строками равно нулю.
Чтобы получить пустую строку из строки длиной i, нужно совершить  i операций удаления, а чтобы получить строку длиной j из пустой, нужно произвести j операций вставки.
Случай, когда обе строки непусты:
В оптимальной последовательности операций их можно произвольно менять местами.
Рассмотрим две последовательные операции:

Две замены одного и того же символа — неоптимально (если мы заменили x на y, потом — y на z, выгоднее было сразу заменить x на z).
Две замены разных символов можно менять местами
Два стирания или две вставки можно менять местами
Вставка символа с его последующим стиранием — неоптимально (можно их обе отменить)
Стирание и вставку разных символов можно менять местами
Вставка символа с его последующей заменой — неоптимально (излишняя замена)
Вставка символа и замена другого символа меняются местами
Замена символа с его последующим стиранием — неоптимально (излишняя замена)
Стирание символа и замена другого символа меняются местами
Пусть S1 кончается на символ «a»,  S2 кончается на символ «b». Есть три варианта:

1. Символ «а», на который кончается S1 в какой-то момент был стёрт. Сделаем это стирание первой операцией. Тогда стирается символ «a», после чего первые i-1 символов S1 превратили в S2 (на что потребовалось dp(i-1, j) операций), значит, всего потребовалось dp(i-1, j)+1 операций.
2. Символ «b», на который кончается S2, в какой-то момент был добавлен. Сделаем это добавление последней операцией. Теперь превратили S1 в первые j-1 символов S2, после чего добавили «b». Аналогично предыдущему случаю, потребовалось dp(i, j-1)+1} операций.
3. Оба предыдущих утверждения неверны. Если добавлять символы справа от финального «a», то, чтобы сделать последним символом «b», нужно было или в какой-то момент добавить его (но тогда утверждение 2 было бы верно), либо заменить на него один из этих добавленных символов (что тоже невозможно, потому что добавление символа с его последующей заменой неоптимально). Значит, символов справа от финального «a» не было добавлено. Самый финальный символ «a» не был удалён, поскольку утверждение 1 неверно. Значит, единственный способ изменения последнего символа — его замена. Заменять его 2 или больше раз неоптимально. Значит:
- если a=b, то последний символ не менялся, поскольку его также не стирали и не приписывали ничего справа от него, то значит, было выполнено dp(i-1,j-1)} операций.
- eсли a!=b, то последний символ менялся один раз, эта замена будет первой. В дальнейшем, аналогично предыдущему случаю, нужно выполнить dp(i-1,j-1)} операций, значит, всего потребуется dp(i-1,j-1)+1} операций.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Используется два цикла - внешний на n символов в первой строке и вложенный цикл на m символов во второй строке.
Итоговая временная сложность: O(n*m), где n - число символов первой строки, m - второй строки

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Используется дополнительная память под матрицу dp и хранение предыдущего состояния dp размером m, O(2*m)=O(m)
Итоговая пространственная сложность: O(m), где m - число символов второй строки
*/

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main() {
    string s, t;
    cin >> s >> t;
    int n = s.length();
    int m = t.length();
    vector<int> dp(m + 1, 0);
    for (int i = 0; i <= m; ++i) {
        dp[i] = i;
    }
    vector<int> prev;
    for (int i = 1; i <= n; ++i) {
        prev = dp;
        dp[0] = i;
        for (int j = 1; j <= m; ++j) {
            if (s[i - 1] == t[j - 1]) {
                dp[j] = prev[j - 1];
            }
            else {
                dp[j] = 1 + min(dp[j - 1], min(prev[j], prev[j - 1]));
            }
        }
    }
    cout << dp[m];
}
