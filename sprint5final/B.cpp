//https://contest.yandex.ru/contest/24810/run-report/108532804/

/*
-- ПРИНЦИП РАБОТЫ --

В качестве примера был использован этот пример:
https://www.geeksforgeeks.org/deletion-in-binary-search-tree/
Если дерево состояло из одной вершины, то после её удаления дерева не останется.
Если удаляем лист, то дерево останется одним деревом и не распадётся на части.
Если удаляем корень, у которого есть оба поддерева, то каждое поддерево станет отдельным деревом.
Если удаляем вершину, у которой есть оба ребёнка и родитель, то дерево распадётся на родительское и два поддерева.
Для того чтобы дерево осталось деревом поиска, на место удалённой вершины надо поставить какую-то другую вершину:
- Самую правую вершину в левом поддереве.
- Самую левую вершину в правом поддереве.
В данном решении используется самая правая в левом поддереве.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Если у вершины P есть потомки, значит, у неё есть только левый ребёнок и нет правого, так как 
P — самая правая вершина в своём поддереве.
Алгоритм действий:
Чтобы не оставить P.left осиротевшим после переноса P, 
надо чтобы P.parent (прародитель P.left, родитель P) усыновил P.left в качестве правого ребенка вместо P.
Теперь у вершины P нет детей, и её можно удалить.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

В худшем случае удаляемый элемент будет находится в листе, т.е. самом последнем узле какой-то ветки, что равно высоте дерева,
т.е. временная сложность зависит от высоты дерева.
Таким образом временная сложность в худшем случае O(h), где h - высота дерева.
По условию задачи - ключи дерева – натуральные числа, не превышающие 10^9.
Если использовать все натуральные числа из этого диапазона и считать, что дерево идеально сбалансировано, 
то тогда высота дерева бует log2(n), где n - число элементов, т.е. h=log n, т.е сложность O(log n).
Для данной задачи log2(10^9)=9*log2(10)=(round)30, т.е. если дерево будет сбалансировано, то можно считать, что максимально высота будет 30.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Т.к. проход дерева осуществляется через рекурсию, то на каждом уровне рекурсии на стеке будет создаваться стековый кадр, 
где выделяется память переданные вызывающей функией аргументы и под локальные перменные метода.
Число вызовов в худшем случае равно высоте дерева.
Таким образом пространственная сложность в худшем случае O(h), где h - высота дерева.
*/

#ifndef REMOTE_JUDGE
struct Node {
    int value;
    Node* left = nullptr;
    Node* right = nullptr;
    Node(Node* left, Node* right, int value) : value(value), left(left), right(right) {}
};
#endif
#ifdef REMOTE_JUDGE
#include "solution.h"
#endif
#include <cassert>

Node* remove(Node* root, int key) {
    if (!root)
        return nullptr;
    if (root->value > key) {
        root->left = remove(root->left, key);
        return root;
    }
    else if (root->value < key) {
        root->right = remove(root->right, key);
        return root;
    }
    else {
        // если нет одного из потомков, то для удаления такого узла достаточно поменять его указатель на присутвующего потомка
        if (!root->left) {
            return root->right;
        }
        else if (!root->right) {
            return root->left;
        }
        else {
            Node* parent = root;
            // Ищем самую правую вершину в левом поддереве. Там лежит самое большое значение из левого поддерева, и оно точно меньше, чем любое значение правого поддерева.
            // Если у вершины P есть потомки, значит, у неё есть только левый ребёнок и нет правого, так как P — самая правая вершина в своём поддереве.
            Node* newRoot = root->left;
            while (newRoot->right) {
                parent = newRoot;
                newRoot = newRoot->right;
            }
            if (parent != root)
                parent->right = nullptr;
            else
                parent->left = nullptr;
            root->value = newRoot->value;
            return root;
        }
    }
}

#ifndef REMOTE_JUDGE
void test() {
    Node node1({ nullptr, nullptr, 2 });
    Node node2({ &node1, nullptr, 3 });
    Node node3({ nullptr, &node2, 1 });
    Node node4({ nullptr, nullptr, 6 });
    Node node5({ &node4, nullptr, 8 });
    Node node6({ &node5, nullptr, 10 });
    Node node7({ &node3, &node6, 5 });
    Node* newHead = remove(&node7, 10);
    assert(newHead->value == 5);
    assert(newHead->right == &node5);
    assert(newHead->right->value == 8);
}

int main() {
    test();
}
#endif