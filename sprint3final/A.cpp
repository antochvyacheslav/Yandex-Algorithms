//https://contest.yandex.ru/contest/23815/run-report/106035341/

/*
-- ПРИНЦИП РАБОТЫ --

1. найти индекс элемента, на который был сдвинут изначальный отсортированный массив
2. выполнить бинарный поиск в той части массива, где находится искомый элемент

для поиска индекса опорного элемента используется тоже бинарный поиск - исходный массив делится попалам, пока выполняется условие
для поиска искомого элемента используется рекурсивный бинарный поиск из 9 урока
https://github.com/Yandex-Practicum/algorithms-theory-examples/blob/master/sprint3/By%20languages/C%2B%2B/lesson3code1.cpp
бинарный поиск на отсортированном массиве работает из O(log n)

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

изначальный массив отсортирован, но т.к. он был неправлиьно скопирован из кольцевого буфера, то начала может находиться в любом месте,
с помощью бинарного поиска находится место, где массив делится на два отсортированных, 
и потом в искомый элемент ищется в соответсвующей части исходного массива

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

поиск индекса опорного элемента работает за O(log n)
бинарный поиск на отсортированном массиве работает из O(log n)
итого в общем будет O(log n)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

вектор, передаётся по ссылке, он не копируется, поэтому его размер O(n) не учитываем,
из дополнительно памяти есть локальные переменные и параметры метода на стеке - они занимают констаный объём памяти O(1),
но на каждом уровне рекурсии локальные переменны и параметры метода будут добавляться в стек вызовов, 
т.е. дополнительная память зависит от глубины рекурсии, т.к. это бинарый поиск, значит O(log n),
в общем итоге простанственная сложность составит O(log n) памяти
*/

#ifdef REMOTE_JUDGE
#include "solution.h"
#endif

#include <vector>
#include <cassert>

int binary_search(const std::vector<int>& vec, int k, int left, int right) {
    if (right <= left) {
        // промежуток пуст
        return -1;
    }
    // промежуток не пуст
    int mid = (left + right) / 2;
    if (vec[mid] == k) {
        // центральный элемент — искомый
        return mid;
    }
    else if (k < vec[mid]) {
        // искомый элемент меньше центрального значит следует искать в левой половине
        return binary_search(vec, k, left, mid);
    }
    else {
        // иначе следует искать в правой половине
        return binary_search(vec, k, mid + 1, right);
    }
}

int broken_search(const std::vector<int>& vec, int k) {
    int left = 0;
    int right = vec.size() - 1;
    while (left < right - 1) {
        int mid = (left + right) / 2;
        // опорный элемент в правой половине, поэтому смещаем левый указатель на середину
        if (vec[left] < vec[mid])
            left = mid;
        // опорный элемент в левой половине, поэтому смещаем левый указатель на середину
        else
            right = mid;
    }
    // опорный элемент
    int pivot = right;
    if (vec[pivot] == k) {
        return pivot;
    }
    else if (k < vec[0]) {
        return binary_search(vec, k, pivot + 1, vec.size());
    }
    else {
        return binary_search(vec, k, 0, pivot);
    }
}

#ifndef REMOTE_JUDGE
void test() {
    std::vector<int> arr;
    arr = { 19, 21, 100, 101, 1, 4, 5, 7, 12 };
    assert(6 == broken_search(arr, 5));
    arr = { 5, 1 };
    assert(1 == broken_search(arr, 1));
    arr = { 8, 10, 0, 2, 4 };
    assert(4 == broken_search(arr, 4));
}

int main() {
    test();
}
#endif 